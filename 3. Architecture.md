This framework is designed to follow **extension model** patterns. Therefore, we can extend any functionality just by adding other dependencies that extend the current functionality. As an example, Quarkus applications will be deployed locally, but if we add the OpenShift module. we can automatically deploy it in OpenShift/K8s just by adding the `@OpenShiftScenario`.

# Concepts

- `Scenario` - infrastructure to bootstrap test cases
- `Services` - how test cases interact with resources
- `Resources` - resource to manage the lifecycle of an application
- `Managed Resource` - environment where resources will be running

# Extension Points

- `Bootstrap extension point` - create your own custom scenario. Examples: OpenShift, Kubernetes, Kogito, Camel, â€¦
- `Annotations extension point` - create your own annotations. @QuarkusApplication, @KafkaContainer, @Container, ...
- `Deployments extension point` - deploy your resources into custom environments: Localhost, OpenShift, Kubernetes

# Packages

Modules within the testing framework must conform to the following package naming conventions:

- `io.quarkus.test.bootstrap` - manage the lifecycle of the tests
- `io.quarkus.test.bootstrap.inject` - services that are injectable at test method level
- `io.quarkus.test.configuration` - configuration facilities
- `io.quarkus.test.logging` - logging facilities and handlers
- `io.quarkus.test.tracing` - tracing facilities
- `io.quarkus.test.scenarios` - scenarios that the module implement, eg: `@OpenShiftScenario`
- `io.quarkus.test.scenarios.annotations` - useful JUnit annotations to disable/enable scenarios
- `io.quarkus.test.services` - services that the module implement, eg: `@QuarkusApplication`, `@Container`
- `io.quarkus.test.services.<service-name>` - bindings to configure the `service-name` to be extended or supported
- `io.quarkus.test.utils` - more utilities
